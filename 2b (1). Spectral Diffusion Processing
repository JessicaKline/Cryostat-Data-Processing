{"cells":[{"cell_type":"code","source":["## processing spectral diffusion data (ie 600x 1s spectra)"],"metadata":{"id":"glevqUg0ds1H"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#@title imports\n","#### Common Imports #####\n","\n","import matplotlib.pyplot as plt\n","import numpy as np\n","import pandas as pd\n","from matplotlib.ticker import MultipleLocator\n","import math\n","import os\n","from os import listdir\n","from os.path import isfile, join\n","import logging\n","from scipy import optimize\n","import seaborn as sns\n","\n","#### Common Imports #####\n","\n","#### RC Params #####\n","\n","plt.rcParams['savefig.dpi'] = 300\n","plt.rcParams['font.size'] = 22\n","plt.rcParams['font.family'] = 'sans-serif'\n","plt.rcParams['font.sans-serif'] = 'Arial'\n","plt.rcParams['xtick.major.pad']='10'\n","plt.rcParams['ytick.major.pad']='4'\n","\n","logging.getLogger('matplotlib.font_manager').disabled = True\n","\n","#### RC Params #####\n"],"metadata":{"cellView":"form","id":"vJBJ6EQftMYy"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#@title helper functions\n","\n","#### Common Helper Functions #####\n","\n","def read_csv(file_path):\n","  g2 = pd.read_csv(file_path)\n","  g2 = g2.to_numpy()\n","  return g2\n","\n","def read_csv_lightfield(file_path):\n","  g2 = pd.read_csv(file_path, header=None)\n","  g2 = g2.to_numpy()\n","  return g2\n","\n","def save_fig(filename):\n","  plt.savefig(filename, bbox_inches = 'tight')\n","\n","def set_figsize(width_, height_):\n","  ff = plt.gcf()\n","  ff.set_figwidth(width_)\n","  ff.set_figheight(height_)\n","  ff.tight_layout()\n","\n","def tick_settings(x_minor = 1, y_minor = 1):\n","  plt.gca().xaxis.set_minor_locator(MultipleLocator(x_minor))\n","  plt.gca().yaxis.set_minor_locator(MultipleLocator(y_minor))\n","  plt.gca().tick_params(which='minor', bottom=True, top=True, left=True, right=True)\n","  plt.gca().tick_params(bottom=True, top=True, left=True, right=True)\n","  plt.tick_params(axis = 'both', direction = 'in', length = 6, width = 1.5)\n","  plt.gca().tick_params(which='minor', direction = \"in\", length = 4, width = 0.75)\n","\n","  for axis in ['top','bottom','left','right']:\n","    plt.gca().spines[axis].set_linewidth(1.5)\n","\n","def plot_settings(y_lim, x_lim, y_min, x_min, x_label, y_label):\n","  plt.gca().set_ylim(y_lim)\n","  plt.gca().set_xlim(x_lim)\n","  tick_settings(y_minor = y_min, x_minor = x_min)\n","\n","  plt.gca().set_xlabel(x_label, fontweight = 'bold')\n","  plt.gca().set_ylabel(y_label, fontweight = 'bold')\n","\n","def save_csv_report(fits, col_lst ,filename):\n","  fits = pd.DataFrame(fits.T)\n","  fits.columns = col_lst\n","  fits.to_csv(filename)\n","\n","def find_nearest(array, value):\n","    array = np.asarray(array)\n","    idx = (np.abs(array - value)).argmin()\n","    return idx\n","\n","def get_onlyfile(folder):\n","  return [f for f in listdir(folder) if isfile(join(folder, f))]\n","\n","#### Common Helper Functions #####\n","\n","def jacobian_transform(x_w, I_w):\n","  hc = 1239.8\n","\n","  x_E_ev = hc/x_w\n","  x_frequency = 3E8/(x_w*1E-9)\n","  I_E = I_w/(x_E_ev**2)\n","  I_E = I_E/(x_frequency**3)\n","  #I_E = I_E/np.sum(I_E)\n","  #I_E = I_E / np.amax(I_E)\n","\n","  return np.array([x_E_ev, I_E]).T\n","\n","def gaussian(x, amplitude1, mean1, stddev1):\n","    return amplitude1/(stddev1*np.sqrt(2*3.14)) * np.exp(-0.5*((x - mean1) /(stddev1))**2)\n","\n","def gaussian_b(x, amplitude1, mean1, stddev1, b):\n","    return amplitude1/(stddev1*np.sqrt(2*3.14)) * np.exp(-0.5*((x - mean1) /(stddev1))**2) + b\n","\n","def gaussian2(x, amplitude1, mean1, stddev1, amplitude2, mean2, stddev2):\n","    return amplitude1/(stddev1*np.sqrt(2*3.14)) * np.exp(-0.5*((x - mean1) /(stddev1))**2) + amplitude2/(stddev2*np.sqrt(2*3.14)) * np.exp(-0.5*((x - mean2) /(stddev2))**2)\n","\n","def gaussian3(x, amplitude1, mean1, stddev1, amplitude2, mean2, stddev2, amplitude3, mean3, stddev3):\n","    return amplitude1/(stddev1*np.sqrt(2*3.14)) * np.exp(-0.5*((x - mean1) /(stddev1))**2) + amplitude2/(stddev2*np.sqrt(2*3.14)) * np.exp(-0.5*((x - mean2) /(stddev2))**2) + amplitude3/(stddev3*np.sqrt(2*3.14)) * np.exp(-0.5*((x - mean3) /(stddev3))**2)"],"metadata":{"id":"LLI7xFaAtS5J","cellView":"form"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#@title sd processing functions\n","def process_PL_slice(background_file, pl_spectra):\n","  bg = read_csv(background_file)\n","  data = read_csv(pl_spectra)\n","\n","\n","  data[:,1] -= bg[:,1]\n","\n","  data = jacobian_transform(data[:,0], data[:,1])\n","  data[:,1] /= np.nanmax(data[:,1])\n","\n","  return data\n","\n","def dell_fitting_eq(t, dell_inf, t_c, sigma):\n","  return np.log((dell_inf**2)*(1-np.exp(-1*t/t_c)) + 2*(sigma**2))\n","\n","def dell_fitting_eq_2(t, dell_inf, t_c, sigma):\n","  return (dell_inf**2)*(1-np.exp(-1*t/t_c)) + 2*(sigma**2)\n","\n","def get_time_averaged_fits(diff, save_location):\n","  temp_sum = np.nansum(diff, axis=0)\n","  max_sum = np.nanmax(temp_sum[1:])\n","  mask = temp_sum >= 0.1*max_sum\n","  temp_diff = np.copy(diff)\n","  for n in range(1, len(temp_diff[0,:])):\n","    if ~mask[n]:\n","      temp_diff[:,n] = np.nan\n","  r = np.nansum(temp_diff[:,1:], axis = 1)\n","\n","  popt, _ = optimize.curve_fit(gaussian_b, diff[:,0], r/np.nanmax(r), p0 = [1, 2.4, 0.01, 0.01], bounds = ([0, 2.3, 0, 0], [10,2.5, 10, 0.5]), nan_policy='omit')\n","\n","  g = gaussian_b(diff[:,0], popt[0], popt[1], popt[2], popt[3])\n","  temp_save = np.array([diff[:,0], r, g])\n","  label_save = ['energy (eV)', 'intensity', 'fit']\n","  save_csv_report(temp_save, label_save, save_location +'Time_Average_Spec.csv')\n","\n","  popt[2] *= 1000*2.355\n","  temp_save = np.array([popt])\n","  label_save = ['fits']\n","  save_csv_report(temp_save, label_save, save_location +'Time_Average_Params.csv')\n","\n","def get_sd_image(background_file, pl_spectra, nan_val):\n","  data = read_csv(pl_spectra)\n","  bg = read_csv(background_file)\n","\n","  f = np.argwhere(data[:,1] > nan_val)\n","  for n in range(0, len(f)):\n","    data[f[n], 1] = np.nan\n","\n","  f = np.argwhere(data[:,0] == data[0,0])\n","\n","\n","  diff = []\n","  for n in range(0, len(f)-1):\n","    # diff.append(f[n] - f[n-1])\n","    diff.append(data[f[n][0]:f[n+1][0]-1,:])\n","\n","  diff = np.array(diff)\n","\n","  for n in range(0, len(diff[:,0,0])):\n","    diff[n,:,1] -= bg[:,1]\n","    data = jacobian_transform(diff[n,:,0], diff[n,:,1])\n","    diff[n,:,0] = data[:,0]\n","    diff[n,:,1] = data[:,1]\n","\n","    sub = np.average(diff[n,700:,1])\n","    diff[n,:,1] -= sub\n","\n","  return diff"],"metadata":{"id":"xXbZRPmQzA-K","cellView":"form"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#@title single frame\n","\n","def get_single_frame_fits(diff, nan_sum, loc1, loc2, save_location, time_bin_s, num_spectra):\n","  E_max_lst = []\n","  Area_lst = []\n","  FWHM_lst = []\n","\n","  ## fitting of single frame spectra\n","  for n in range(0, num_spectra):\n","    if np.nansum(diff[:,n]) > 0:\n","      popt, _ = optimize.curve_fit(gaussian_b, diff[:,0], diff[:,n]/np.nanmax(diff[:,n]), p0 = [1, 2.4, 0.01, 0.05], bounds = ([0, 2.3, 0, 0], [10,2.5, 10, 0.5]), nan_policy='omit')\n","\n","      if np.nansum(diff[loc1:loc2,n]) > nan_sum and (popt[1]-2.3) > 0.01 and (2.5-popt[1]) > 0.01:\n","        E_max_lst.append(popt[1])\n","        FWHM_lst.append(popt[2]*1000*2.355)\n","      else:\n","        E_max_lst.append(np.nan)\n","        FWHM_lst.append(np.nan)\n","      Area_lst.append(np.nansum(diff[loc1:loc2,n]))\n","    else:\n","      E_max_lst.append(np.nan)\n","      FWHM_lst.append(np.nan)\n","      Area_lst.append(np.nan)\n","\n","  FWHM_lst = np.array(FWHM_lst)\n","\n","  time_lst = np.arange(0,num_spectra*time_bin_s, time_bin_s)\n","  temp_save = np.array([time_lst, E_max_lst, FWHM_lst, Area_lst])\n","  label_save = ['time (s)', 'E max (eV)', 'FWHM (meV)', 'Area']\n","  save_csv_report(temp_save, label_save, save_location +'Time_Slice_Data.csv')\n","\n","\n","  ## start of analysis from https://pubs.acs.org/doi/pdf/10.1021/acsphotonics.3c00420\n","  dell_sq_lst = []\n","  dell_t_lst = []\n","  dell_cov = []\n","\n","  for start_ in range(0, len(E_max_lst)):\n","    for comp_ in range(start_+1, len(E_max_lst)):\n","      if ~np.isnan(E_max_lst[start_]) and ~np.isnan(E_max_lst[comp_]):\n","        dell_sq_lst.append(((E_max_lst[start_] - E_max_lst[comp_])*1000)**2)\n","        dell_t_lst.append(np.abs(time_lst[start_] - time_lst[comp_]))\n","\n","  unique_dell_t = np.unique(dell_t_lst)\n","\n","  weighted_dell_sq = []\n","  for uniq in unique_dell_t:\n","    f = np.argwhere(dell_t_lst == uniq)\n","    temp = []\n","    for loc in f:\n","      temp.append(dell_sq_lst[loc[0]])\n","    if len(temp) > 1:\n","      weighted_dell_sq.append(np.nanmean(temp)*np.sqrt(len(temp))/np.nanstd(temp)*np.log(uniq/(uniq+time_bin_s)))\n","    else:\n","      weighted_dell_sq.append(np.average(temp)*np.sqrt(len(temp))/1*np.log(uniq/(uniq+time_bin_s)))\n","\n","  weighted_dell_sq = np.array(weighted_dell_sq)\n","  weighted_dell_sq += 2*((np.nanmean(FWHM_lst)/2.355)**2)\n","  try:\n","    popt2, _ = optimize.curve_fit(dell_fitting_eq_2, unique_dell_t[:-1], weighted_dell_sq[:-1], p0 = [1, 15, 2], bounds = ([0,0,0], [100, 100, 100]), nan_policy='omit')\n","  except:\n","    popt2 = [1,1,1]\n","  fit2 = dell_fitting_eq_2(unique_dell_t, popt2[0], popt2[1], popt2[2])\n","\n","  temp_save = np.array([unique_dell_t, weighted_dell_sq, fit2])\n","  label_save = ['time (s)', '<dell^2> (meV)^2', 'fit (meV^2)']\n","  save_csv_report(temp_save, label_save, save_location +'Dell_Sq_Fit.csv')\n","\n","  temp_save = np.array([popt2])\n","  label_save = ['fits']\n","  save_csv_report(temp_save, label_save, save_location +'Dell_Sq_Params.csv')"],"metadata":{"cellView":"form","id":"NzWn8Ad6aBhQ"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#@title plotting\n","def plot_spec_diffusion(diff, loc1, loc2, save_location, save, bins, bin_div, time_bin_s, num_spectra, max_sum):\n","  fig, axs = plt.subplot_mosaic([['a', 'a', 'a', 'b', 'b'],['a', 'a', 'a', 'b', 'b'],['c', 'c', 'c', 'e', 'e'],['d', 'd', 'd', 'e', 'e'], ['f', 'f', 'f', 'g', 'g'], ['f', 'f', 'f', 'g', 'g']], layout='tight')\n","  ## spectra diffusion\n","  label = 'a'\n","\n","  diff_temp = np.copy(diff)\n","  diff_temp = np.flipud(diff_temp)\n","  #axs[label].imshow(diff[loc1:loc2,1:]/max_sum, origin = 'lower', extent=([0, time_bin_s*num_spectra, diff[loc1,0], diff[loc2,0]]), aspect = 'auto')\n","  axs[label].imshow(diff_temp[loc1:loc2,1:]/max_sum, origin = 'lower', extent=([0, time_bin_s*num_spectra, diff_temp[loc1,0], diff_temp[loc2,0]]), aspect = 'auto')\n","  # axs[label].clim([0,1])\n","  for im in axs[label].get_images():\n","    im.set_clim(0, np.nanmax(diff_temp[loc1:loc2,1:]/max_sum))\n","    #im.set_clim(0, np.nanmax(diff[loc1:loc2,1:]/max_sum))\n","  axs[label].set_xlabel('Time (s)')\n","  axs[label].set_ylabel('Energy (eV)')\n","\n","  ## time average\n","  label = 'b'\n","  time_data = read_csv(save_location + 'Time_Average_Spec.csv')\n","  time_params = read_csv(save_location + 'Time_Average_Params.csv')\n","  SF_data = read_csv(save_location + 'Time_Slice_Data.csv')\n","\n","  axs[label].plot(time_data[:,2]/np.amax(time_data[:,2]), time_data[:,1], color = 'k', linewidth = 3)\n","  axs[label].plot(time_data[:,3], time_data[:,1], color = 'r', linestyle = '--', linewidth = 2)\n","  #axs[label].set_ylim([diff[loc1,0], diff[loc2,0]])\n","  axs[label].set_ylim([diff[loc2,0], diff[loc1,0]])\n","  axs[label].set_xlim([0,1])\n","  axs[label].text(0.15, 1.005*diff[loc1,0], 'E$_{max}$ (eV): ' + str(time_params[1,1])[0:5] + '\\nEm Max Broad (meV): ' + str((time_params[1,1]-np.nanmedian(SF_data[:,2]))*1000)[0:4] + '\\nFWHM (meV): ' + str(time_params[2,1])[0:2] + '\\nFWHM Broad (meV): ' + str(time_params[2,1]-np.nanmedian(SF_data[:,3]))[0:4], fontsize = 12, verticalalignment = 'top', horizontalalignment = 'left',\n","                  backgroundcolor = 'white')\n","  axs[label].set_xlabel('Intensity')\n","\n","\n","  # ### pl max\n","\n","  label = 'c'\n","  axs[label].plot(SF_data[:,1], (SF_data[:,2] - time_params[1,1])*1000, color = 'k')\n","  # axs[label].set_ylim([1.002*np.amax(popt_lst[:,1]), 0.998*np.amin(popt_lst[:,1])])\n","  axs[label].set_xlim([0,num_spectra*time_bin_s])\n","  axs[label].set_xlabel('Time (s)')\n","  axs[label].set_ylabel('$\\Delta$ Em. Max (meV)')\n","\n","  # ## fwhm\n","  label = 'd'\n","  axs[label].plot(SF_data[:,1], (SF_data[:,3] - time_params[2,1]), color = 'k')\n","  # axs[label].set_ylim([1.002*np.amax(popt_lst[:,1]), 0.998*np.amin(popt_lst[:,1])])\n","  axs[label].set_xlim([0,num_spectra*time_bin_s])\n","  axs[label].set_xlabel('Time (s)')\n","  axs[label].set_ylabel('$\\Delta$ FWHM (meV)')\n","\n","  #fwhm vs e max\n","  label = 'e'\n","  axs[label].hist2d((SF_data[:,2] - time_params[1,1])*1000, (SF_data[:,3] - time_params[2,1]), bins = np.arange(-1*bins,bins+bin_div,bin_div))\n","  axs[label].set_xlabel('$\\Delta$ Em. Max (meV)')\n","  axs[label].set_ylabel('$\\Delta$ FWHM (meV)')\n","\n","  ### spectra in time\n","  label = 'f'\n","  pal = sns.color_palette('flare_r', n_colors = num_spectra)\n","  for n in range(1,num_spectra+1):\n","    # if np.nansum(diff[n,:,1]) < 0:\n","    axs[label].plot(diff[loc1:loc2,0], diff[loc1:loc2,n], color = pal[n-1])\n","\n","  axs[label].set_xlabel('Energy (eV)')\n","  axs[label].set_ylabel('Intensity')\n","\n","  ### time constant\n","  label = 'g'\n","  dell_plot = read_csv(save_location +'Dell_Sq_Fit.csv')\n","  dell_vals = read_csv(save_location +'Dell_Sq_Params.csv')\n","\n","  axs[label].scatter(dell_plot[:,1], dell_plot[:,2], color = 'k')\n","  axs[label].plot(dell_plot[:,1], dell_plot[:,3], color = 'r', linestyle = '--')\n","\n","  axs[label].text(100, (np.nanmax(dell_plot[:,3])+np.nanmin(dell_plot[:,3]))/2, 't$_{SD}$ (s): ' + str(dell_vals[1,1])[0:4], fontsize = 12)\n","\n","  axs[label].set_xlabel('time (s)')\n","  axs[label].set_ylabel('dell^2 (meV^2)')\n","\n","\n","  set_figsize(width_ = 12, height_ = 15)\n","\n","  if save:\n","    save_fig(save_location + 'Spectral_Diffusion_Report.png')"],"metadata":{"id":"VviTu4nd5XCv","cellView":"form"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#@title comb spec\n","def combine_spectra(pl1, pl2, background):\n","  pl1 = read_csv_lightfield(pl1)\n","  pl2 = read_csv_lightfield(pl2)\n","  background = read_csv_lightfield(background)\n","\n","\n","  pl1 = np.reshape(pl1[:,1], [300,-1]).T\n","  pl2 = np.reshape(pl2[:,1], [300,-1]).T\n","\n","  arr = []\n","  arr.append(1239.8/background[:,0])\n","  for n in range(0,300):\n","    temp = pl1[:,n] - background[:,1]\n","    temp[temp>800] = np.nan\n","    temp = jacobian_transform(background[:,0], temp)\n","    #temp[:,1] /= np.nansum(temp[:,1])\n","    arr.append(temp[:,1])\n","\n","  temp = np.zeros(len(background[:,1]))\n","  temp[:] = np.nan\n","  for n in range(0,600):\n","    arr.append(temp)\n","\n","  for n in range(0,300):\n","    temp = pl2[:,n] - background[:,1]\n","    temp[temp>800] = np.nan\n","    temp = jacobian_transform(background[:,0], temp)\n","    #temp[:,1]/= np.nansum(temp[:,1])\n","    arr.append(temp[:,1])\n","\n","  arr = np.reshape(arr, [1201, -1]).T\n","\n","  return arr\n"],"metadata":{"id":"wp0QnaT_ahkm","cellView":"form"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#@title spectral diffusion\n","\n","folder_string = 'insert file path here'     ## file path to overarching folder X which contains X/QD{n}/Spectra\n","\n","background_file = 'insert file path here'   ## background spectrum\n","\n","common_tag = 'insert tag here'            ## common save tag to data (often contains measurement parameters, ie '_472nm_15MHz_1s_300frames')\n","\n","time_bin_s = 1\n","\n","fwhm = []\n","em_max = []\n","\n","for qd_num in range(0,200):\n","  checkpath = folder_string+f'QD{qd_num}/'\n","  save_location = folder_string+f'QD{qd_num}/Spectra/Analyzed Data/'\n","\n","  if os.path.exists(checkpath) == True:\n","    print(checkpath)\n","\n","    if os.path.exists(save_location) == False:\n","        os.mkdir(save_location)\n","\n","    ## assumes that the SD data was collected in two parts\n","    pl_loc_1 = checkpath+f'Spectra/QD{qd_num}'+common_tag'_part1.csv'\n","    pl_loc_2 = checkpath+f'Spectra/QD{qd_num}'+common_tag'_part2.csv'\n","\n","    print('combine spectra')\n","    arr = combine_spectra(pl_loc_1, pl_loc_2, background_file)\n","    save_csv_report(arr.T, np.arange(0,1201), save_location+'processed_spectra.csv')\n","\n","    ## set plotting and fitting bounds\n","    loc1 = find_nearest(arr[:,0], 1239.8/490)\n","    loc2 = find_nearest(arr[:,0], 1239.8/540)\n","\n","    temp_sum = np.nansum(arr, axis=0)\n","    max_sum = np.nanmax(temp_sum[1:])\n","\n","    ## 1 gaussian fits of all spectra and analysis of SD from https://pubs.acs.org/doi/pdf/10.1021/acsphotonics.3c00420\n","    print('single frame fits')\n","    get_single_frame_fits(arr, 0.1*max_sum, loc1, loc2, save_location, time_bin_s = time_bin_s, num_spectra = 1200)\n","\n","    ## fit of summed spectrum\n","    print('time averaged fits')\n","    get_time_averaged_fits(arr, save_location)\n","\n","    ## plotting output\n","    plot_spec_diffusion(diff = arr, loc1 = loc1, loc2 = loc2, save_location = save_location, save = True, bins = 50, bin_div = 1, time_bin_s = time_bin_s, num_spectra = 1200, max_sum = max_sum)\n","\n","    print()\n","    plt.close()"],"metadata":{"id":"yDI1b9YpEYCP"},"execution_count":null,"outputs":[]},{"cell_type":"code","source":["#@title check fits\n","\n","## plotting to check fits/analysis of the data\n","\n","import matplotlib.image as mpimg\n","import time\n","\n","directory = 'insert file path here'\n","\n","plt.ion()\n","\n","for qd_num in range(0,200):\n","  qd_num_path = directory + f'QD{qd_num}/'\n","  if os.path.exists(qd_num_path) == True:\n","    spectra_loc_path = qd_num_path + 'Spectra/Analyzed Data/'\n","\n","    print(qd_num)\n","    img = mpimg.imread(spectra_loc_path+f'Spectral_Diffusion_Report.png')\n","\n","    plt.imshow(img)\n","    plt.axis('off')\n","    set_figsize(width_ = 12, height_ = 15)\n","\n","    plt.show()\n","\n","    time.sleep(1)\n","    keep_trace = input('Move to next (any key)')\n","    plt.close()"],"metadata":{"id":"oo89yEb6y0js"},"execution_count":null,"outputs":[]}],"metadata":{"colab":{"provenance":[],"authorship_tag":"ABX9TyNFvfhzNTb39LlGNWgNPSVM"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}